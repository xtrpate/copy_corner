# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path
import sys
import subprocess
import mysql.connector
import tkinter as tk
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, messagebox, ttk, Listbox
from datetime import datetime

admin_name = "Admin"  # Default if not passed
if len(sys.argv) > 1:
    admin_name = sys.argv[1]  # Get admin name from command-line argument

# --- Global Variables ---
all_users = []  # To store fetched users for autocomplete
selected_user_id = None  # To store the ID if a single user is selected


# --- Database Connection & User Fetching ---
def get_db_connection():
    try:
        return mysql.connector.connect(
            host="localhost",
            user="root",
            password="",
            database="copy_corner_db"
        )
    except mysql.connector.Error as err:
        messagebox.showerror("Database Error", f"Connection failed: {err}")
        return None


def fetch_users_for_autocomplete():
    """Fetches user_id and username from the users table for autocomplete."""
    global all_users
    conn = get_db_connection()
    if not conn: return []

    try:
        cursor = conn.cursor(dictionary=True)
        # Fetching id and username
        query = "SELECT user_id, username FROM users ORDER BY username ASC"
        cursor.execute(query)
        all_users = cursor.fetchall()
        cursor.close()
        conn.close()
        return all_users
    except mysql.connector.Error as err:
        messagebox.showerror("Database Error", f"Error fetching users: {err}")
        return []


def fetch_notification_history():
    """Fetches recent notification history for the activity feed."""
    conn = get_db_connection()
    if not conn: return []

    try:
        cursor = conn.cursor(dictionary=True)

        # First, let's check the structure of the notifications table
        cursor.execute("SHOW COLUMNS FROM notifications")
        columns = [column['Field'] for column in cursor.fetchall()]
        print(f"Notifications table columns: {columns}")

        # Build query based on available columns
        if 'notification_id' in columns:
            id_column = 'notification_id'
        elif 'id' in columns:
            id_column = 'id'
        else:
            id_column = '*'

        # Build the query dynamically based on available columns
        query = f"""
            SELECT 
                {id_column},
                user_id,
                subject,
                message,
                created_at
            FROM notifications 
            ORDER BY created_at DESC 
            LIMIT 50
        """

        cursor.execute(query)
        notifications = cursor.fetchall()
        cursor.close()
        conn.close()

        # Enrich notifications with username information
        enriched_notifications = []
        for notification in notifications:
            enriched_notif = notification.copy()
            if notification['user_id']:
                # Find username for this user_id
                user = next((u for u in all_users if u['user_id'] == notification['user_id']), None)
                enriched_notif['recipient'] = user['username'] if user else f"User {notification['user_id']}"
            else:
                enriched_notif['recipient'] = "All Users"
            enriched_notifications.append(enriched_notif)

        return enriched_notifications

    except mysql.connector.Error as err:
        print(f"Error fetching notification history: {err}")
        # Return empty list but don't show error message to user
        return []


def create_notifications_table():
    """Create the notifications table if it doesn't exist with proper structure."""
    conn = get_db_connection()
    if not conn: return False

    try:
        cursor = conn.cursor()

        # Create notifications table with proper structure
        create_table_query = """
            CREATE TABLE IF NOT EXISTS notifications (
                id INT AUTO_INCREMENT PRIMARY KEY,
                user_id INT NULL,
                subject VARCHAR(255) NOT NULL,
                message TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL
            )
        """
        cursor.execute(create_table_query)
        conn.commit()
        cursor.close()
        conn.close()
        print("Notifications table created/verified successfully")
        return True

    except mysql.connector.Error as err:
        print(f"Error creating notifications table: {err}")
        return False


# --- UI Interaction Functions ---

def toggle_user_entry():
    """Enables/disables the user entry and clears/hides suggestions based on radio button."""
    global selected_user_id
    if send_to_var.get() == "single":
        user_entry.config(state=tk.NORMAL)
        user_entry.delete(0, tk.END)  # Clear previous entry
        selected_user_id = None  # Reset selected user
    else:
        user_entry.config(state=tk.DISABLED)
        user_entry.delete(0, tk.END)
        hide_suggestions()
        selected_user_id = None  # Reset selected user


def update_user_suggestions(event=None):
    """Filters users based on entry and updates the listbox."""
    global selected_user_id
    search_term = user_entry.get().lower()
    user_listbox.delete(0, tk.END)  # Clear previous suggestions
    selected_user_id = None  # Reset if user is typing again

    if not search_term:
        hide_suggestions()
        return

    matches = [user for user in all_users if search_term in user['username'].lower()]

    if matches:
        for user in matches:
            # Store both username and id, display username
            user_listbox.insert(tk.END, f"{user['username']} (ID: {user['user_id']})")
        # Position listbox below entry
        entry_x = user_entry.winfo_x()
        entry_y = user_entry.winfo_y()
        entry_height = user_entry.winfo_height()
        user_listbox.place(x=entry_x, y=entry_y + entry_height, width=user_entry.winfo_width())
        user_listbox.lift()  # Bring listbox to the front
    else:
        hide_suggestions()


def select_user_from_list(event=None):
    """Puts the selected username in the entry and stores the ID."""
    global selected_user_id
    selection_indices = user_listbox.curselection()
    if not selection_indices:
        return

    selected_text = user_listbox.get(selection_indices[0])
    # Extract username and ID
    username = selected_text.split(" (ID: ")[0]
    user_id_str = selected_text.split(" (ID: ")[1].replace(")", "")
    selected_user_id = int(user_id_str)

    user_entry.delete(0, tk.END)
    user_entry.insert(0, username)
    hide_suggestions()


def hide_suggestions(event=None):
    """Hides the suggestion listbox."""
    # Add a small delay so click event on listbox can register first
    window.after(150, user_listbox.place_forget)


# --- Activity Feed Functions ---

def update_activity_feed():
    """Updates the activity feed with recent notifications."""
    # Clear existing feed items
    for widget in feed_inner_frame.winfo_children():
        widget.destroy()

    notifications = fetch_notification_history()

    if not notifications:
        # Show message if no notifications
        no_notifs_label = tk.Label(
            feed_inner_frame,
            text="No notifications sent yet",
            font=("Inter", 10),
            bg="#FFFFFF",
            fg="#666666",
            justify="center"
        )
        no_notifs_label.pack(pady=20)
        return

    for notification in notifications:
        create_feed_item(notification)


def create_feed_item(notification):
    """Creates a single feed item in the activity feed."""
    item_frame = tk.Frame(feed_inner_frame, bg="#FFFFFF", relief="solid", bd=1)
    item_frame.pack(fill="x", padx=5, pady=3)

    # Format the date
    created_at = notification['created_at']
    if isinstance(created_at, str):
        date_str = created_at
    else:
        date_str = created_at.strftime("%m/%d/%y %H:%M") if created_at else "Unknown date"

    # Create the content
    recipient = notification.get('recipient', 'Unknown')
    subject = notification.get('subject', 'No subject')

    # Truncate long subjects
    if len(subject) > 25:
        subject = subject[:22] + "..."

    # Recipient label
    recipient_label = tk.Label(
        item_frame,
        text=f"To: {recipient}",
        font=("Inter Bold", 9),
        bg="#FFFFFF",
        fg="#000000",
        anchor="w"
    )
    recipient_label.pack(fill="x", padx=5, pady=(5, 0))

    # Subject label
    subject_label = tk.Label(
        item_frame,
        text=f"Subject: {subject}",
        font=("Inter", 9),
        bg="#FFFFFF",
        fg="#333333",
        anchor="w"
    )
    subject_label.pack(fill="x", padx=5, pady=(2, 0))

    # Date label
    date_label = tk.Label(
        item_frame,
        text=date_str,
        font=("Inter", 8),
        bg="#FFFFFF",
        fg="#666666",
        anchor="w"
    )
    date_label.pack(fill="x", padx=5, pady=(2, 5))

    # Bind hover effect
    def on_enter(event):
        item_frame.config(bg="#F0F0F0")
        for child in item_frame.winfo_children():
            child.config(bg="#F0F0F0")

    def on_leave(event):
        item_frame.config(bg="#FFFFFF")
        for child in item_frame.winfo_children():
            child.config(bg="#FFFFFF")

    item_frame.bind("<Enter>", on_enter)
    item_frame.bind("<Leave>", on_leave)

    # Also bind to labels
    for label in item_frame.winfo_children():
        label.bind("<Enter>", on_enter)
        label.bind("<Leave>", on_leave)


def refresh_activity_feed():
    """Refresh the activity feed and update scroll region."""
    update_activity_feed()
    feed_canvas.configure(scrollregion=feed_canvas.bbox("all"))


# --- Send Notification Logic ---

def send_notification():
    """Validates input and sends the notification."""
    send_to = send_to_var.get()
    user_text = user_entry.get().strip()
    subject = subject_entry.get("1.0", tk.END).strip()
    message = message_text.get("1.0", tk.END).strip()

    # --- Validation ---
    if not send_to:
        messagebox.showerror("Input Error", "Please select 'Single User' or 'All User'.")
        return

    if send_to == "single":
        if not user_text:
            messagebox.showerror("Input Error", "Please enter or select a username.")
            return
        # More robust check: ensure the entered text corresponds to a selected ID
        if selected_user_id is None:
            # Check if the current text matches exactly one user (case-insensitive)
            matches = [user for user in all_users if user['username'].lower() == user_text.lower()]
            if len(matches) == 1:
                select_user_id = matches[0]['user_id']  # Use the matched ID
                recipient_name = matches[0]['username']
                print(f"Assuming user: {matches[0]['username']} (ID: {select_user_id})")
            else:
                messagebox.showerror("Input Error",
                                     "Please select a valid user from the suggestions or ensure the username is exact.")
                return
        else:
            select_user_id = selected_user_id  # Use the ID stored during listbox selection
            # Find the username for the selected ID
            recipient_name = next((user['username'] for user in all_users if user['user_id'] == select_user_id),
                                  "Unknown User")

    if not subject:
        messagebox.showerror("Input Error", "Please enter a subject.")
        return

    if not message:
        messagebox.showerror("Input Error", "Please enter a message.")
        return

    # --- Sending Logic ---
    try:
        conn = get_db_connection()
        if not conn: return
        cursor = conn.cursor()

        if send_to == "single":
            # Insert notification for a single user
            sql = """
                INSERT INTO notifications (user_id, subject, message)
                VALUES (%s, %s, %s)
            """
            cursor.execute(sql, (select_user_id, subject, message))
            conn.commit()
            messagebox.showinfo("Success", f"Notification sent to {recipient_name}!")

        elif send_to == "all":
            # Fetch all user IDs first
            cursor.execute("SELECT user_id FROM users")
            user_ids = [row[0] for row in cursor.fetchall()]

            if not user_ids:
                messagebox.showwarning("No Users", "There are no users to send notifications to.")
                return

            # Prepare data for bulk insert
            sql = """
                 INSERT INTO notifications (user_id, subject, message)
                 VALUES (%s, %s, %s)
             """
            data_to_insert = [(user_id, subject, message) for user_id in user_ids]
            cursor.executemany(sql, data_to_insert)
            conn.commit()
            messagebox.showinfo("Success", f"Notification sent to all {len(user_ids)} users!")

        cursor.close()
        conn.close()

        # Clear fields after sending
        send_to_var.set(None)  # Reset radio
        user_entry.delete(0, tk.END)
        subject_entry.delete("1.0", tk.END)
        message_text.delete("1.0", tk.END)
        toggle_user_entry()  # Disable user entry if needed

        # Refresh activity feed to show the new notification
        refresh_activity_feed()

    except mysql.connector.Error as err:
        messagebox.showerror("Database Error", f"Failed to send notification: {err}")
    except Exception as e:
        messagebox.showerror("Error", f"An unexpected error occurred: {e}")


# --- Rounded Rectangle Function ---
def round_rectangle(canvas, x1, y1, x2, y2, r=15, **kwargs):
    points = [
        x1 + r, y1, x2 - r, y1, x2, y1, x2, y1 + r,
        x2, y2 - r, x2, y2, x2 - r, y2, x1 + r, y2,
        x1, y2, x1, y2 - r, x1, y1 + r, x1, y1
    ]
    return canvas.create_polygon(points, smooth=True, **kwargs)


# --- Sidebar Buttons with Navigation ---
def open_admin_dashboard():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_dashboard.py", admin_name])


def open_admin_print():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_print.py", admin_name])


def open_admin_report():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_report.py", admin_name])


def open_admin_user():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_user.py", admin_name])


# --- Logout Function ---
def logout():
    messagebox.showinfo("Logged Out", "Logout successful!")
    subprocess.Popen([sys.executable, "login.py"])
    window.destroy()


def create_rounded_menu_button(canvas, x, y, w, h, text, command=None):
    rect = round_rectangle(canvas, x, y, x + w, y + h, r=10, fill="#FFFFFF", outline="#000000", width=1)
    txt = canvas.create_text(x + 25, y + 8, text=text, anchor="nw", fill="#000000", font=("Inter Bold", 15))

    def on_click(event):
        if command:
            command()

    def on_hover(event):
        canvas.itemconfig(rect, fill="#E8E8E8")
        window.config(cursor="hand2")

    def on_leave(event):
        canvas.itemconfig(rect, fill="#FFFFFF")
        window.config(cursor="")

    for tag in (rect, txt):
        canvas.tag_bind(tag, "<Button-1>", on_click)
        canvas.tag_bind(tag, "<Enter>", on_hover)
        canvas.tag_bind(tag, "<Leave>", on_leave)


# --- GUI Setup ---
OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(
    r"D:\downloadss\New folder\Tkinter\Tkinter-Designer-master\build\assets\frame5")


def relative_to_assets(path: str) -> Path:
    asset_file = ASSETS_PATH / Path(path)
    if not asset_file.is_file():
        print(f"Warning: Asset not found at {asset_file}")
    return asset_file


window = Tk()
window_width = 905
window_height = 567

screen_width = window.winfo_screenwidth()
screen_height = window.winfo_screenheight()
x = int((screen_width / 2) - (window_width / 2))
y = int((screen_height / 2) - (window_height / 2))
window.geometry(f"{window_width}x{window_height}+{x}+{y}")
window.configure(bg="#FFFFFF")
window.title("Admin Notification")

canvas = Canvas(
    window,
    bg="#FFFFFF",
    height=567,
    width=907,
    bd=0,
    highlightthickness=0,
    relief="ridge"
)

canvas.place(x=0, y=0)
canvas.create_rectangle(
    19.0,
    15.0,
    890.0,
    555.0,
    fill="#FFF6F6",
    outline="#000000")

canvas.create_rectangle(
    40.0,
    33.0,
    869.0,
    537.0,
    fill="#FFFFFF",
    outline="#000000")

canvas.create_rectangle(
    50.0,
    41.0,
    253.0,
    530.0,
    fill="#FFFFFF",
    outline="#000000")

# --- Load Logo ---
try:
    image_image_1 = PhotoImage(file=relative_to_assets("image_1.png"))
    image_1 = canvas.create_image(151.0, 79.0, image=image_image_1)
except tk.TclError:
    print("Warning: Could not load logo image_1.png")
    image_image_1 = None

canvas.create_text(
    125.0,
    130.0,
    anchor="nw",
    text="ADMIN",
    fill="#000000",
    font=("Inter Bold", 15 * -1)
)

# --- Main Content Area ---
canvas.create_text(
    281.0,
    48.0,
    anchor="nw",
    text="Notifications",
    fill="#000000",
    font=("Inter Bold", 45 * -1)
)

canvas.create_rectangle(
    260.0,
    32.0,
    261.0,
    537.0,
    fill="#000000",
    outline="")

canvas.create_rectangle(
    281.0,
    100.0,
    849.0,
    517.0,
    fill="#FFFFFF",
    outline="#000000")

# --- Send To Options ---
canvas.create_text(314.0, 119.0, anchor="nw", text="Send to", fill="#000000", font=("Inter Bold", 14 * -1))
send_to_var = tk.StringVar(value=None)

single_user_rb = ttk.Radiobutton(
    window,
    text="Single User",
    variable=send_to_var,
    value="single",
    command=toggle_user_entry,
    style="TRadiobutton"
)
single_user_rb.place(x=375.0, y=117.0)

all_user_rb = ttk.Radiobutton(
    window,
    text="All User",
    variable=send_to_var,
    value="all",
    command=toggle_user_entry,
    style="TRadiobutton"
)
all_user_rb.place(x=489.0, y=117.0)

# --- User Entry and Autocomplete ---
canvas.create_text(334.0, 161.0, anchor="nw", text="User:", fill="#000000", font=("Inter Bold", 20 * -1))
user_entry = Entry(
    window,
    bd=0,
    bg="white",
    highlightthickness=1,
    highlightcolor="#000000",
    highlightbackground="#000000",
    font=("Inter", 12),
    state=tk.DISABLED
)
user_entry.place(
    x=395.0,
    y=159.0,
    width=248.0,
    height=26.0)

user_listbox = Listbox(
    window,
    bd=1,
    relief="solid",
    font=("Inter", 10),
    height=4
)

# Bindings for autocomplete
user_entry.bind("<KeyRelease>", update_user_suggestions)
user_listbox.bind("<ButtonRelease-1>", select_user_from_list)
user_entry.bind("<FocusOut>", hide_suggestions)

# --- Subject Entry ---
canvas.create_text(307.0, 200.0, anchor="nw", text="Subject:", fill="#000000", font=("Inter Bold", 20 * -1))
subject_entry = Text(
    window,
    bd=0,
    bg="white",
    highlightthickness=1,
    highlightcolor="#000000",
    highlightbackground="#000000",
    font=("Inter", 12),
    height=1
)
subject_entry.place(
    x=395.0,
    y=198.0,
    width=248.0,
    height=26.0)

# --- Message Text Area ---
canvas.create_text(429.0, 231.0, anchor="nw", text="Message", fill="#000000", font=("Inter Bold", 23 * -1))
message_text = Text(
    window,
    bd=0,
    bg="white",
    highlightthickness=1,
    highlightcolor="#000000",
    highlightbackground="#000000",
    font=("Inter", 12),
    wrap=tk.WORD
)
message_text.place(
    x=297.0,
    y=260.0,
    width=363.0,
    height=204.0)

# --- Buttons ---
back_btn_rect = round_rectangle(canvas, 301, 473, 301 + 59, 473 + 35, r=5, fill="#FFFFFF", outline="#000000", width=1,
                                tags="back_btn")
back_btn_text = canvas.create_text(301 + 59 / 2, 473 + 35 / 2, text="Back", fill="#000000", font=("Inter Bold", 16),
                                   anchor="center", tags="back_btn")

send_btn_rect = round_rectangle(canvas, 370, 473, 370 + 59, 473 + 35, r=5, fill="#000000", outline="#000000", width=1,
                                tags="send_btn")
send_btn_text = canvas.create_text(370 + 59 / 2, 473 + 35 / 2, text="Send", fill="#FFFFFF", font=("Inter Bold", 16),
                                   anchor="center", tags="send_btn")

canvas.tag_bind("send_btn", "<Button-1>", lambda e: send_notification())

# Button Hover Effects
for tag in ("back_btn", "send_btn"):
    canvas.tag_bind(tag, "<Enter>", lambda e: window.config(cursor="hand2"))
    canvas.tag_bind(tag, "<Leave>", lambda e: window.config(cursor=""))

# --- Scrollable Activity Feed ---
# Create main container for activity feed
feed_container = tk.Frame(window, bg="#FFFFFF")
feed_container.place(x=671.0, y=110.0, width=166.0, height=395.0)

# Create canvas and scrollbar for activity feed
feed_canvas = Canvas(feed_container, bg="#FFFFFF", highlightthickness=0)
feed_scrollbar = ttk.Scrollbar(feed_container, orient="vertical", command=feed_canvas.yview)

feed_inner_frame = tk.Frame(feed_canvas, bg="#FFFFFF")

feed_inner_frame.bind(
    "<Configure>",
    lambda e: feed_canvas.configure(scrollregion=feed_canvas.bbox("all"))
)

feed_canvas.create_window((0, 0), window=feed_inner_frame, anchor="nw")
feed_canvas.configure(yscrollcommand=feed_scrollbar.set)

# Pack canvas and scrollbar
feed_canvas.pack(side="left", fill="both", expand=True)
feed_scrollbar.pack(side="right", fill="y")


# Bind mousewheel scrolling to activity feed
def on_feed_mousewheel(event):
    feed_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")


feed_canvas.bind_all("<MouseWheel>", on_feed_mousewheel)

# Activity Feed Title
canvas.create_text(
    696.0,
    119.0,
    anchor="nw",
    text="Activity Feed",
    fill="#000000",
    font=("Inter Bold", 18 * -1)
)

# --- Sidebar Buttons ---
create_rounded_menu_button(canvas, 73, 162, 151, 38, "Dashboard", open_admin_dashboard)
create_rounded_menu_button(canvas, 73, 218, 151, 38, "User", open_admin_user)
create_rounded_menu_button(canvas, 73, 275, 151, 38, "Print Jobs", open_admin_print)
create_rounded_menu_button(canvas, 73, 332, 151, 38, "Reports", open_admin_report)
create_rounded_menu_button(canvas, 73, 389, 151, 38, "Settings")
create_rounded_menu_button(canvas, 89, 462, 111, 38, "Logout", logout)

# --- Initial Setup ---
fetch_users_for_autocomplete()
toggle_user_entry()
create_notifications_table()  # Ensure table exists
refresh_activity_feed()  # Load initial activity feed

window.resizable(False, False)
window.mainloop()